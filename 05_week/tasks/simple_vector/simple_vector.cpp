/*ектор чисел
Необходимо реализовать класс SimpleVector, представляющий упрощенную реализацию контейнера std::vector для целочисленных элементов типа int в динамической памяти.

Класс предоставляет следующий функционал:

Конструктор по умолчанию
Конструктор, принимающий размер вектора и заполняющий его нулями
Конструктор, принимающий список инициализации std::initializer_list<int>, что позволит писать SimpleVector v = {1, 3, 5}
Конструктор копирования
Конструктор перемещения
Операторы присваивания копированием
Оператор присваивания перемещением
Деструктор
Метод Swap - принимает другой вектор и меняет содержимое текущего вектора с ним местами
Операторы индексирования []- позволяет изменять содержимое для неконстантного вектора
Метод Size - возвращает число элементов в векторе
Метод Capacity - возвращает текущее число выделенных ячеек памяти под вектор.
Метод Empty - возвращает true, если вектор пуст
Метод Data - прямой доступ к памяти, не позволяющий вносить изменения
Метод PushBack который вставляет элемент в конец вектора.
Метод PopBack - удаляет последний элемент вектора. При этом изменяется только размер, выделенную память изменять не нужно.
Метод Insert - принимает позицию (или const int*) и элемент, вставляет элемент перед указанной позицией, возвращает указатель на вставленный элемент, позволяющий вносить изменения. При вставке элементы контейнера, начиная с указанной позиции до конца вектора смещаются на одну позицию. Если передана некорректная позиция, вставка не происходит, возвращается указатель за последний элемент контейнера.
Метод Erase - принимает позицию (или const int*), удаляет элемент в указанной позиции и возвращает указатель на элемент, который был следующим за удаляемым. Элементы после указанной позиции сдвигаются. Если передана некорректная позиция, удаление не производится.
Метод Clear - очистить вектор. При этом, как правило, изменяется только размер, память очищать не нужно и выполнять релокации тоже.
Метод Resize - принимает размер и значение (по умолчанию 0), изменяет размер массива на заданный. Если переданный размер совпадает с текущим, то без изменений. Если меньше, то изменяет размер. Если больше, то при необходимости производит релокацию и заполняет элементы заданным значением
Метод Reserve - принимает новое значение вместимости, позволяя зарезервировать место в векторе. Если текущий Capacity не меньше переданного, то метод не должен ничего делать. В противном случае выполните релокацию в массив размера заданной вместимости.
Поддержка работы range-based for для контейнера. В данном случае для простоты допустимо возвращать указатели на первый элемент и за последний, концепция итераторов будет обсуждаться позже.
Операторы сравнения на равенство и неравенство, учитывающие размер и поэлементное сравнение элементов
При добавлении элемента, если память, выделенная для вектора, заполнена, то выполните релокацию: выделите массив вдвое большего размера, скопируйте элементы туда, после чего удалите старый массив. В этом случае вместимость должна увеличиться вдвое. Для вектора, сконструированного с помощью конструктора по умолчанию, вместимость == 0, при добавлении элемента вместимость становится 1.

Примечание
Запрещено использовать стандартные контейнеры (std::vector, умные указатели)
Устройство вектора обсуждалось в конце третьей лекции
Для поддержки range-based for необходимы методы begin, end или внешние функции begin, end, принимающие заданную коллекцию, поэтому допустимо, чтобы они не соответствовали стайлгайду. Если стайлгайд не хочется
Для совместимости с алгоритмами стандартной библиотеки STL может потребоваться swap, ситуация аналогичная, но поскольку требуется внутри класса Swap, достаточно реализовать внешнюю функцию, вызывающую метод Swap контейнера
*/

// simple_vector.cpp
#include <algorithm>
#include <initializer_list>
#include <cstring>  // для memcpy

class SimpleVector {
private:
    int* data_;
    size_t size_;
    size_t capacity_;

public:
    // Конструктор по умолчанию
    SimpleVector() : data_(nullptr), size_(0), capacity_(0) {}  // пустой указатель

    // Конструктор, принимающий размер вектора и заполняющий его нулями
    explicit SimpleVector(size_t size) : data_(new int[size]), size_(size), capacity_(size) {
        for (size_t i = 0; i < size_; ++i)  data_[i] = 0;// заполнение нулями.
    }

    // Конструктор, принимающий размер и значение для заполнения
    SimpleVector(size_t size, int data) : data_(new int[size]), size_(size), capacity_(size) {
        for (size_t i = 0; i < size_; ++i)  data_[i] = data;// заполнение нулями.
    }

    // ККонструктор, принимающий список инициализации std::initializer_list<int>, что позволит писать SimpleVector v = {1, 3, 5}
    SimpleVector(std::initializer_list<int> init) : data_(new int[init.size()]), size_(init.size()), capacity_(init.size()) {
        std::copy(init.begin(), init.end(), data_);   // 
    }

    // Конструктор копирования
    SimpleVector(const SimpleVector& obj){
    
        if(obj.capacity_ == 0) data_ = nullptr;   // проверка, если емкость 0, то nullptr
        else                    data_ = new int[obj.capacity_]; // иначе выделяем место для объекта
        
        // переписывание данных
        size_ = obj.size_;
        
        capacity_ = obj.capacity_;
        
        std::copy(obj.data_, obj.data_ + obj.size_, data_);
    } 

    // Конструктор перемещения
    SimpleVector(SimpleVector&& obj) noexcept : data_(obj.data_), size_(obj.size_), capacity_(obj.capacity_) {
        // скопировали в списке инициализации, теперь обнуляем исходник
        obj.data_ = nullptr;
        obj.size_ = 0;
        obj.capacity_ = 0;
    }

    // Оператор присваивания копированием
    SimpleVector& operator=(const SimpleVector& obj) {
        if (this != &obj) { // проверка на самого себя
            SimpleVector temp(obj);
            Swap(temp);
        }
        return *this;
    }

    // Оператор присваивания перемещением
    SimpleVector& operator=(SimpleVector&& obj) noexcept {
        if (this != &obj) { // проверка на самого себя
            delete[] data_; // очистка
            data_ = obj.data_;  //присвоение
            size_ = obj.size_;
            capacity_ = obj.capacity_;
            
            // обнуляем исходник
            obj.data_ = nullptr;
            obj.size_ = 0;
            obj.capacity_ = 0;
        }
        return *this;
    }

    // Деструктор
    ~SimpleVector() {  delete[] data_; }
    
    // Метод Swap - принимает другой вектор и меняет содержимое текущего вектора с ним местами
    void Swap(SimpleVector& obj) noexcept {

        size_t temp = obj.size_;  // переменная для временного хранения size_ и capacity_
        
        obj.size_ = size_;  
        size_ = temp;
        
        temp = obj.capacity_;
        obj.capacity_ = capacity_;
        capacity_ = temp;
              
        int* tempDdata; // переменная для временного хранения data_
        
        tempDdata = obj.data_;
        obj.data_ = data_;
        data_ = tempDdata;
    }

    // Операторы индексирования []- позволяет изменять содержимое для неконстантного вектора
    int& operator[](size_t i) {
        return data_[i];
    }

    const int& operator[](size_t i) const {
        return data_[i];
    }
    // Метод Size - возвращает число элементов в векторе
    size_t Size() const { return size_; }

    // Метод Capacity - возвращает текущее число выделенных ячеек памяти под вектор.
    size_t Capacity() const { return capacity_; }

    // Метод Empty - возвращает true, если вектор пуст
    bool Empty() const { return size_ == 0; }

    // Метод Data - прямой доступ к памяти, не позволяющий вносить изменения
    const int* Data() const { return data_; }

    // Метод PushBack который вставляет элемент в конец вектора.
    void PushBack(int value) {
    // места может не быть, сначала проверка, есть ли место, .если нет увеличиваем емкость на единицу.
        if (size_ == capacity_) { 
            size_t new_capacity = capacity_ * 2;//  т.к. есть требование "В этом случае вместимость должна увеличиться вдвое"
            if(new_capacity == 0) new_capacity = 1;
            Reserve(new_capacity);
        }
        data_[size_++] = value;
    }

    // Метод PopBack - удаляет последний элемент вектора. При этом изменяется только размер, выделенную память изменять не нужно.
    void PopBack() {   if (size_ > 0) --size_;  }

  // Метод Insert - принимает позицию (или const int*) и элемент, вставляет элемент перед указанной позицией, возвращает указатель на вставленный элемент, позволяющий вносить изменения. При вставке элементы контейнера, начиная с указанной позиции до конца вектора смещаются на одну позицию. Если передана некорректная позиция, вставка не происходит, возвращается указатель за последний элемент контейнера.
    int* Insert(const int* pos, int data) {
        if ((pos < data_) || (pos > data_ + size_))  return data_ + size_; // проверка, что указатель указатель места вклейки валиден 
        
        size_t i = pos - data_;  // расчет индекса начала сдвига
        
        // возможно Размер совпал с емкостью,
        if (size_ == capacity_) { // Тогда надо увеличить емкость на 1
            size_t new_capacity = capacity_ + 1;
            Reserve(new_capacity);
        }
        
        // Сдвигаем с элементы после места вклейки вправо
        for (size_t j = size_; j > i; --j) data_[j] = data_[j - 1];
        
        data_[i] = data;  // вклеиваем элемент
        ++size_;  // помним про то, что надо увеличить размер 
        
        return data_ + i;
    }

// Метод Erase - принимает позицию (или const int*), удаляет элемент в указанной позиции и возвращает указатель на элемент, который был следующим за удаляемым. Элементы после указанной позиции сдвигаются. Если передана некорректная позиция, удаление не производится.

    int* Erase(const int* pos) {
        if (pos < data_ || pos >= data_ + size_) return data_ + size_;  // проверка, что указатель указатель места вклейки валиден 
        
        size_t i = pos - data_;  // расчет индекса начала сдвига
        
        // Сдвигаем элементы 
        for (size_t j = i; j < size_ - 1; ++j) data_[j] = data_[j + 1];
        
        --size_; // помним про то, что надо увеличить размер 
        
        return data_ + i;
    }

    // Метод Clear - очистить вектор. При этом, как правило, изменяется только размер, память очищать не нужно и выполнять релокации тоже.
    void Clear() {  size_ = 0; }

    // Метод Reserve - принимает новое значение вместимости, позволяя зарезервировать место в векторе. Если текущий Capacity не меньше переданного, то метод не должен ничего делать. В противном случае выполните релокацию в массив размера заданной вместимости.
    void Resize(size_t newSize, int data = 0) {
        if (newSize == size_)  return;  // метод не должен ничего делать.
        
        if (newSize < size_) size_ = newSize;
        else {
            if (newSize > capacity_) {
                Reserve(newSize);
            }
            
            // Заполняем элементы значением data
            for (size_t i = size_; i < newSize; ++i) {
                data_[i] = data;
            }
            size_ = newSize;
        }
    }

    // Метод Reserve
    void Reserve(size_t new_capacity) {
        if (new_capacity <= capacity_) return;  // метод не должен ничего делать.
        
        int* new_data = new int[new_capacity];
        if (data_) {
            std::copy(data_, data_ + size_, new_data);
            delete[] data_;
        }
        data_ = new_data;
        capacity_ = new_capacity;
    }

    // Поддержка работы range-based for для контейнера. В данном случае для простоты допустимо возвращать указатели на первый элемент и за последний, концепция итераторов будет обсуждаться позже.
    int* begin() {  return data_;  }

    const int* begin() const {  return data_;  }

    int* end() {  return data_ + size_; }

    const int* end() const { return data_ + size_; }

    // Операторы сравнения на равенство и неравенство, учитывающие размер и поэлементное сравнение элементов
    bool operator==(const SimpleVector& obj) const {
        if (size_ != obj.size_) {
            return false;
        }
        for (size_t i = 0; i < size_; ++i) {
            if (data_[i] != obj.data_[i]) {
                return false;
            }
        }
        return true;
    }

    bool operator!=(const SimpleVector& obj) const {
        return !(*this == obj);
    }
};

// Для совместимости с алгоритмами стандартной библиотеки STL может потребоваться swap, ситуация аналогичная, но поскольку требуется внутри класса Swap, достаточно реализовать внешнюю функцию, вызывающую метод Swap контейнера
void swap(SimpleVector& lhs, SimpleVector& rhs) noexcept {
    lhs.Swap(rhs);
}
