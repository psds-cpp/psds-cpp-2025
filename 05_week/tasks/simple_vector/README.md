# Вектор чисел

Необходимо реализовать класс `SimpleVector`, представляющий упрощенную реализацию
контейнера `std::vector` для целочисленных элементов типа `int` в динамической
памяти. 

Класс предоставляет следующий функционал:

- Конструктор по умолчанию
- Конструктор, принимающий размер вектора и заполняющий его нулями
- Конструктор, принимающий список инициализации `std::initializer_list<int>`,
  что позволит писать `SimpleVector v = {1, 3, 5}`
- Конструктор копирования
- Конструктор перемещения
- Операторы присваивания копированием
- Оператор присваивания перемещением 
- Деструктор
- Метод `Swap` - принимает другой вектор и меняет содержимое текущего вектора с ним местами
- Операторы индексирования `[]`- позволяет изменять содержимое для неконстантного вектора
- Метод `Size` - возвращает число элементов в векторе
- Метод `Capacity` - возвращает текущее число выделенных ячеек памяти под вектор.
- Метод `Empty` - возвращает `true`, если вектор пуст
- Метод `Data` - прямой доступ к памяти, не позволяющий вносить изменения
- Метод `PushBack` который вставляет элемент в конец вектора.
- Метод `PopBack` - удаляет последний элемент вектора. При этом изменяется только размер,
  выделенную память изменять не нужно.
- Метод `Insert` - принимает позицию (или `const int*`) и элемент, вставляет элемент перед 
  указанной позицией, возвращает указатель на вставленный элемент, позволяющий вносить изменения.
  При вставке элементы контейнера, начиная с указанной позиции до конца вектора смещаются 
  на одну позицию. Если передана некорректная позиция, вставка не происходит, возвращается 
  указатель за последний элемент контейнера.
- Метод `Erase` - принимает позицию (или `const int*`), удаляет элемент в указанной позиции
  и возвращает указатель на элемент, который был следующим за удаляемым.
  Элементы после указанной позиции сдвигаются. Если передана некорректная позиция, удаление
  не производится.
- Метод `Clear` - очистить вектор. При этом, как правило, изменяется только размер, память 
  очищать не нужно и выполнять релокации тоже.
- Метод `Resize` - принимает размер и значение (по умолчанию 0), изменяет размер массива на
  заданный. Если переданный размер совпадает с текущим, то без изменений. Если меньше, то
  изменяет размер. Если больше, то при необходимости производит релокацию и заполняет элементы
  заданным значением
- Метод `Reserve` - принимает новое значение вместимости, позволяя зарезервировать место в 
  векторе. Если текущий `Capacity` не меньше переданного, то метод не должен ничего делать. 
  В противном случае выполните релокацию в массив размера заданной вместимости.
- Поддержка работы range-based for для контейнера. В данном случае для простоты
  допустимо возвращать указатели на первый элемент и за последний, концепция итераторов
  будет обсуждаться позже.
- Операторы сравнения на равенство и неравенство, учитывающие размер и поэлементное
  сравнение элементов

При добавлении элемента, если память, выделенная для вектора, заполнена, то выполните
релокацию: выделите массив вдвое большего размера, скопируйте элементы туда,
после чего удалите старый массив. В этом случае вместимость должна увеличиться вдвое.
Для вектора, сконструированного с помощью конструктора по умолчанию, вместимость == 0, 
при добавлении элемента вместимость становится 1.

## Примечание

- **Запрещено** использовать стандартные контейнеры (`std::vector`, умные указатели)
- Устройство вектора обсуждалось в конце третьей лекции
- Для поддержки range-based for необходимы методы `begin`, `end` или внешние функции
  `begin`, `end`, принимающие заданную коллекцию, поэтому допустимо, чтобы они не 
  соответствовали стайлгайду. Если стайлгайд не хочется 
- Для совместимости с алгоритмами стандартной библиотеки **STL** может потребоваться
  `swap`, ситуация аналогичная, но поскольку требуется внутри класса `Swap`, достаточно
  реализовать внешнюю функцию, вызывающую метод `Swap` контейнера
