/*
  Коровья строка
Существуют разные подходы к управлению данными при копировании. Можно выделить следующие семантики:

value-семантика - при копировании объекта происходит глубокое копирование (deep copy), все значения полностью объекта полностью копируются (реализовано в большинстве классов стандартной библиотеки C++).
reference-семантика - при копировании объекта его содержимое не копируется, а разделяется между копиями посредством ссылки или указателя. Также существует подход, который называют поверхностное копирование (shallow copy), когда происходит копирование только верхнего уровня оригинального объекта, а ссылки на внутренние части объекта остаются общими (реализовано по умолчанию в некоторых других языках).
cow-семантика (copy-on-write) - при копировании объекта создается shallow copy, что позволяет использовать объект на чтение без дополнительных затрат ресурсов, но при изменении объекта создается настоящая глубокая копия и изменения вносятся уже в копию. Таким образом, копирование совершается только при внесении изменений, что в определенных сценариях использования объекта позволяет увеличить производительность и уменьшить затраты на ресурсы.
Cow-семантика применяется в реализации строк Яндекса и фреймворка Qt.

Необходимо реализовать класс CowString, который представляет собой упрощенную реализацию строки с copy-on-write семантикой.

Класс предоставляет следующий функционал:

Конструктор по умолчанию — создает пустую строку
Конструктор от const char*
Конструктор от std::string
Конструктор копирования — увеличивает счетчик ссылок, не копирует данные
Оператор присваивания копированием — увеличивает счетчик ссылок, не копирует данные
Конструктор перемещения
Оператор присваивания перемещением
Деструктор
Методы НЕ вызывающие копирования:

Метод Size - возвращает длину строки без учета терминирующего нуля \0
Метод ToCstr - возвращает указатель на данные
Метод ToString - возвращает std::string
Оператор [] - доступ к символу для чтения
Оператор неявного преобразования к C-строке
Методы, обеспечивающие модификацию на собственной копии данных:

Оператор [] - доступ к символу для записи
Метод Append - добавляет строку из C-строки или std::string
Метод Substr - принимает позицию и количество символов (по умолчанию от начала до конца строки), возвращает соответствующую подстроку. Если позиция начала превышает длину, то возвращаем пустую строку.
Метод Clear - очистка строки
Для реализации строки удобно вынести все необходимые поля в отдельную структуру и кроме этого хранить в ней счетчик ссылок ref_count.

Правильно поддерживая ref_count всегда будет известно, когда нужно удалять данные строки или когда нужно превращать shallow-copy в deep-copy.

Примечание
Запрещено использовать std::string в реализации и умные указатели
Рекомендуется определять методы вне класса
При необходимости вспомогательные методы реализуются в закрытой части класса
Тесты оператор [] не проверяют на индекс вне диапазона
Проблемы реализации
В предполагаемой реализации имеется следующая проблема: при использовании модифицирующей версии оператора [] пользователь может сохранить ссылку и модифицировать символ позже, что нарушит cow-семантику. Для упрощения решать её не требуется. В Qt используют QCharRef для решения этой проблемы.
*/

#include <cstring>
#include <string>

class CowString {
private:
    char* data_;  // указатель на данные
    size_t size_;  // размер
    size_t capacity_;  // емкость
    size_t* ref_count_;  // количество копий.

  // Универсальный конструктор.
  void createNewCowString(const char* data, size_t len) {
    if ((data == nullptr) || (len == 0)) capacity_ = 1;
    else capacity_ = len + 1;
    
    ref_count_ = new int(1);
    size_ = len;
    data_ = new char[capacity_];
    ref_count_ = new size_(capacity_); 
    if ((data == nullptr) || (len == 0)) data_[0] = 0;  // не указано что писать в пустую строку.
    else for(size_t i = 0, i < len, i++) data_[i] = data[i];
}

public:
    static const size_t npos = static_cast<size_t>(-1);
    
    // Конструктор по умолчанию — создает пустую строку
    CowString() {createNewCowString(nullptr, 0);}

    // Конструктор от const char*
    CowString(const char* data, size_t len)  {createNewCowString(data, len);}

    // Конструктор от std::string
    CowString(const std::string& str)  {createNewCowString(str.c_str(), str.length());}

    // Конструктор копирования — увеличивает счетчик ссылок, не копирует данные
    CowString(const CowString& obj) : data_(obj.data_), size_(obj.size_), capacity_(obj.capacity_), ref_count_(obj.ref_count_) {
      ++(*ref_count_);
    }

    // Оператор присваивания копированием — увеличивает счетчик ссылок, не копирует данные
    CowString& operator=(const CowString& obj) {
      if (this == &obj) return *this;  // присвоение самому себе.
              
      data_ = obj.data_;
      size_ = other.size_;
      capacity_ = other.capacity_;
      ref_count_ = other.ref_count_;
      
      if (ref_count_) {
          ++(*ref_count_);
      }

    }


    // Конструктор перемещения
    CowString(CowString&& obj) noexcept : data_(obj.data_), size_(obj.size_), capacity_(obj.capacity_), ref_count_(obj.ref_count_) {
      // новую создали при заполнении полей, сейчас надо "освободить" перемещенную.
      obj.data_ = new char[1];
      obj.size_ = 0;
      obj.capacity_ = 1;
      obj.data_[0] = '\0';
      obj.ref_count_ = new int(1);
    }

    // Оператор присваивания перемещением
    CowString& operator=(CowString&& obj) noexcept {
        if (this == &obj) return *this;

        // копируем
        data_ = obj.data_;
        size_ = obj.size_;
        capacity_ = obj.capacity_;
        ref_count_ = obj.ref_count_;

        // очистка
        obj.capacity_ = 1;
        obj.data_ = new char[capacity_];
        obj.size_ = capacity_ - 1;
        obj.data_[size_] = '\0';
        obj.ref_count_ = new size_t i(1);
      }

    // Деструктор
    ~CowString() {
      if (ref_count_) {
            --(*ref_count_);
            if (*ref_count_ == 0) {
                delete[] data_;
                delete ref_count_;
                data_ = nullptr;
                size_ = 0;
                capacity_ = 0;
                ref_count_ = nullptr;
            }
        }
      }

// Методы НЕ вызывающие копирования:





Оператор неявного преобразования к C-строке
Методы, обеспечивающие модификацию на собственной копии данных:
    // Метод Size - возвращает длину строки без учета терминирующего нуля \0
    size_t Size() const return size_;

    // Метод ToCstr - возвращает указатель на данные
    const char* ToCstr() const return data_;

    // Метод ToString - возвращает std::string
    std::string ToString() const return std::string(data_, size_);

    // Оператор [] - доступ к символу для чтения
    const char& operator[](size_t index) const return data_[index];

    // Оператор неявного преобразования к C-строке
    operator const char*() const return data_;

    // Методы, обеспечивающие модификацию на собственной копии данных:

};
