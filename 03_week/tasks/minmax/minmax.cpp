#include <stdexcept>
#include <vector>
/*
Функция должна найти максимальное и минимальное число в переданном ей std::vector<int>. 
1.Вернуть должна пару итераторов, указывающих на миминмал и максимал элементы
2.Нельзя алгоритмы
3.Надо найти максимал и минимал элемент за один проход
4.для пустого контейнера необходимо вернуть пару итераторов на конец контейнера.
5.В случае нескольких одинаковых элементов, итератор на минимум должен указывать
  на первое вхождение, итератор на максимум на последнее вхождение соответствующих
  элементов

// Спустя несколько попыток решить задачу, наконец дошло что обычная структура не подойдет, надо бы использовать std::pair как возвращаемое значение
// Думаю никто не обидется если длинное некрасивое нечто в возвращаемом значении заменю одной фразой, так приятнее.
// Хотя наверно можно было просто написать auto в возвр. значении, но мне не нравится эта непонятная штука, не очевидная.
//Итераторы ведут себя примерно также как указатели, но они могут быть и не указателями, а хоть чем. Это абстракция некая над указателем, если можно так сказать
*/

using IteratorsPairReturn = std::pair<std::vector<int>::const_iterator,std::vector<int>::const_iterator> ;

IteratorsPairReturn MinMax(const std::vector<int>& wetArray) 
{
    if (wetArray.empty() == true) return {wetArray.end(), wetArray.end()};

    //оба итератора на .begin потому что если вектор не пустой, первый элемент одновременно является и текущим минимумом, и текущим максимумом. По сути
    auto minIt = wetArray.begin();
    auto maxIt = wetArray.begin();
    //Тогда начинаем итерироваться с +1 значения, тк первый это и есть и минимум и максимум, до тех пор пока его не изменим
        for (auto iter = wetArray.begin() + 1; iter != wetArray.end(); ++iter) {
            if (*iter < *minIt) {
            minIt = iter; 
        }        
            else if (*iter >= *maxIt) { 
                maxIt = iter; 
            }
    }

    return std::make_pair(minIt, maxIt);
}
