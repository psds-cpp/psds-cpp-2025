#include <cstddef>
#include <stdexcept>

// !!!! ВАЖНО !!!!  Изначальное объявление функции изменено в части инициализации передаваемого элемента с «char delimiter = ' '» на «char delimiter».
size_t CharChanger(char array[], size_t size, char delimiter) {

    char symbol;             // Актуальный символ.
    char prevSymbol;         // Предыдущий символ.
    char newSymbol = 0;      // Новый символ.
    size_t i = 0;            // счетчик.
    size_t j = 0;            // счетчик итераций для индексации элементов обновленного массива.
    char numMatch = 0;
    prevSymbol = ~array[i];
  
  
  while(i != size)    // Проверка.
  {
    symbol = array[i];    // Присваиваем значение элемента массива для анализа.
  
    if(('0' <= symbol) && (symbol <= '9'))  newSymbol = '*';                          // Если символ -  цифра меняем ее на ‘*’.
    else if(('a' <= symbol) && (symbol <= 'z'))  newSymbol = symbol - ('a' - 'A');    // Если символ – сточная буква, меняем ее на заглавную. 
    else if(('A' <= symbol) && (symbol <= 'Z'))  newSymbol = symbol;                  // Если символ – заглавная буква – ничего не делаем.
    else if(symbol == ' ') newSymbol = delimiter;                                     // Пробел меняем на спец символ. 
    else     newSymbol = '_';                                                         // Все остальные символы заменяем на ‘_’.
    
    if(symbol != prevSymbol)    // Проверка совпадения текущего символа с предыдущим. 
    {
      prevSymbol = symbol;      // Запоминаем символ.
        
      if(numMatch != 0)        // Количество совпадений равно 0?
      {
        if(array[i-1] != ' ')    // Проверяем, прядущий проверяемый символ – пробел. Если да то не нужно печатать количество со впавших символов. 
        {
          if(numMatch >= 9) array[j] = '0';    // Если количество совпадении больше 10 (9 т.к. 10-1). Печатаем 0.
          else              array[j] = '0' + numMatch + 1;    // Иначе печатаем количество одинаковых символов подряд. 
          j++;
        }
      }
      numMatch = 0;            // Обнуляем количество совпадений. 
      array[j] = newSymbol;    // Записываем изменений элемент в массив символов. 
      j++;                     // Увеличение счетчика итераций для индексации элементов обновленного массива.
      
    }
    else    numMatch++;        //Символы совпали, увеличиваем счетчик итераций. 
    
    i++;                      // Счетчик для анализируемых элементов массива. 
      
    if(symbol == '\0') {     // Проверка символа окончания строки. 
      j = j-1;               // уменьшаем счетчик для записи символа окончания строки в обновлённый массив.
      array[j] = '\0';       // записываем символ окончания строки
      return j;               // возвращаемое значение - номер последнего элемента обнавленного массива.
    }
  }
  array[j] = '\0';
  
  return j;
    
}
